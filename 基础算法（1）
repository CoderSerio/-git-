# **基础算法（1）**

## 排序

### quic_sort

```
#include<stdio.h>

void quick_sort(int *q,int l,int r);

int main()
{
	int a[999];
	int n,m;
	int i;
	int *q=a;
	scanf("%d",&n);//n个数， 
	int l=0,r=n-1;
	for(i=0;i<n;i++)
	scanf("%d",&a[i]);
	quick_sort(q,l,r);
	for(i=0;i<n;i++)
	printf("%d",a[i]);
	return 0;
 } 
 void quick_sort(int *q,int l,int r)
 {
 	if(l>=r) return;
 	int x=q[(l+r+1)/2];//x是分界点，以真实的数为分界点
 	int i=l;         //i=l-1；j=r+1;
 	int j=r;
 	int a;
 	while(i<r){
 		do i++;while(q[i]<x);
 		do j--;while(q[j]>x);
 		if(i<j){
 			a=q[i];
 			q[i]=q[j];
 			q[j]=a;
 			
		 }
	 }
	 quick_sort(q,l,i-1);//节点以左
	 quick_sort(q,i,r);//节点以右
	
 }
```

​			*注意边界问题，切记取到左右边界，如果用j，x!=q[r];用i,x!=q[l],

​			* 本排序方法为先排序后递归

### merge_sort

* 先递归后排序

* 归并——合二为一。准备两个已经排好序的数组和第三个用来存数的数组，分别用一个指针指向两个数组的第一个元素，小的一方后移指针，并将指针所指的数移到第三个数组。以此类推。

  //两个排好序的数组是指将一个数组在一个函数里分为左右两部分，一直递归到最小单位，左右各自递归排好后就形成两个以排好序的数组

* 分界点mid=1/2*（l+r)

  ```
  /*merge_sort*/
  #include<stdio.h>
  const int N=1e6+10;
  int a[100];
  int tmp[100];
  
  void merge_sort(int q[],int l,int r);
  int main(){
  	int n;
  	scanf("%d",&n);
  	for(int i=0;i<n;i++){
  		scanf("%d",&a[i]);
  	}
  	merge_sort(a,0,n-1);
  	for(int i=0;i<n;i++){
  		if(i!=n)printf("%d",a[i]);
  		else printf("%d\n",a[n]);	}
  	return 0;
  }
  void merge_sort(int q[],int l,int r){
  	if(l>=r)return;//当区间里的个数是一个或是没有的话，return
  	int mid=(l+r)/2;//r=(0+9)/2=4;//以中间位置为分界点
  	merge_sort(q,l,mid);
  	merge_sort(q,mid+1,r);
  	int k=0,i=l,j=mid+1;
  	while(i<=mid&&j<=r){
  		if(a[i]>a[j]){
  			tmp[k++]=a[j++];
  		}else tmp[k++]=a[i++];
  	}
  	while(i<=mid)tmp[k++]=a[i++];
  	while(j<=r)tmp[k++]=a[j++];
  	for(i=l,j=0;i<=r;i++,j++){
  		a[i]=tmp[j];//把结果拿回来，把结果赋值到tmp里去了，再赋值回来
  	}
  }
  ```

  

### Bisection method

* 本质：边界。找到一个性质，使得整个区间一分为二，一半满足性质，一半不满足性质，寻找性质的边界

* 1）mid=(l+r+1)/2    找第一个边界点

  ​      if(check(mid))-----true-----在区间[mid,r]内

  ​						-----false-----在区间[l,mid-1]内

* 2）mid=(l+r)/2

  ​     if(check(mid))-----true-----在区间[l,mid]内

  ​							-------false------在区间[mid+1,r]

* 选择模板

  * 先写cheek函数  

    true和false如何更新---->l=mid要+1，r=mid无需加1

    * 为什么要补上加1

      当l=r-1时

  ​              若不补，mid=(l+r)/2=l

  ​             此时若if(check(mid))为ture->[mid,r]  l=mid仍为l

  ​             死循环

  ​             而补上+1后，mid=(l+r+1)/2=r;

  ​              此时l=mid=r,l==r return;

  ​             cout<<"-1 -1"<<end 1

```
int n,m;

int main(){
	scanf("%d %d",&n,&m);
	for(int i=0;i<n;i++)
	scanf("%d",&q[i]);
	while(m--){
		int x;
		scanf("%d",&x);
	}
	int l=0;int r=n-1;
	while(l<r){
		int mid=(l+r)>>1;
		if(q[mid]>=x)r=mid;
		else l=mid+1;
	}
	if(q[i]!=x)cout<<"-1 -1"<<endl;
	eles{
		cout<<1<<'';
		int l=0,r=n-1;
		while(l<r){
			int mid=l+r+1>>1;
			if(q[mid]<=x)l=mid;
			else r=mid-1;
		}
		cout<<1<<endl;}
	}
	return 0;
}
```

