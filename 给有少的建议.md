# kmp算法



- kmp算法是用来处理在字符串 str1(大小为n)中寻找有多少个子串 str2(大小为n)的一种算法



- 这种问题我们的暴力做法就是==将子串一位一位的往后移动与母串进行比对==，但是呢这种==时间复杂度过高==：

   在对比的时候我们可以发现例如（为了方便我们这里下标从1开始数）：

​               ` str2:"abababab"`

​       	    `str1:"abababc"`

​               `str1[6]!=str2[6]`

按照暴力做法的话我们是将str1往后移动一位，然后再进行遍历，但是我们可以发现 str1的==$[1,4]$==与==$[3,6]$==是相同的，因此我们就可以直接将str1的==$[1,4]$==移到==$[3,6]$==的位置，可以减少中间浪费的时间

​        ![pic1](C:\Users\桂志强\Desktop\画图.png)



所以我们可以通过求数组的各个大小的最大相同前缀^1^和后缀^2^来记录下子串最少需要移动的步减少时间

下面让我们看看代码

 ```c++
 #include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], w[N];

int main()
{
    cin >> n >> w + 1 >> m >> s + 1;

    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && w[i] != w[j + 1]) j = ne[j];
        if (w[i] == w[j + 1]) j ++ ;
        ne[i] = j;
    }    //求字符串不同个数字符的最大相同的前缀和后缀
    
    for (int i = 1, j = 0; i <= m; i ++ )
    {
        while (j && s[i] != w[j + 1]) j = ne[j];
        if (s[i] == w[j + 1]) j ++ ;
        if (j == n)
        {
            printf("%d ", i - n);
            j = ne[j];
        }
    }
    
    return 0;
}
 ```
- 1：字符串前缀：从字符串头部开始在子串

- 2：字符串后缀：从字符串尾部往前获得的子串